## GO学习笔记

### 指针

#### 指针介绍

#####  1. 什么是指针

>在计算机科学中，指针（Pointer）是一种变量，它存储了一个内存地址的值。简单来说，指针是一个用于存储内存地址的变量。这个地址可以是任何数据（如整数、字符、数组、对象等）在内存中的位置。
>
>通过使用指针，可以实现对内存中数据的间接访问。指针可以用来传递数据、修改数据，以及动态分配和释放内存等。在许多编程语言中，特别是低级语言如 C 和 C++，指针是一项重要的概念。
>
>指针通常包括两个部分：地址和类型。地址是内存位置的值，类型表示该地址上存储的数据的类型。指针的操作包括获取地址（取址操作符 &）、获取地址上的值（间接引用操作符 *）以及指针的赋值和比较等。
>
>指针的使用需要小心谨慎，因为错误的指针操作可能会导致程序崩溃或产生难以调试的错误。正确地使用指针可以提高程序的效率和灵活性，但也需要程序员对内存管理有一定的了解和责任。

#####  2. Go 的指针和 C 语言的指针有什么区别

1. 指针声明和操作符：在 C 语言中，使用星号（*）来声明指针类型和进行间接引用操作，而在 Go 语言中，指针类型使用 `*` 进行声明，但间接引用操作使用`.` 运算符，而不是 `*`
2. 空指针：在 C 语言中，可以将指针设置为 NULL，表示指针不指向任何有效的内存地址。而在 Go 语言中，使用 `nil` 表示空指针
3. 内存管理：在 C 语言中，程序员负责手动分配和释放内存，使用 `malloc()` 和 `free()` 等函数。而在 Go 语言中，有垃圾回收器负责自动管理内存，程序员无需手动释放内存。这种自动内存管理可以减少内存泄漏和悬挂指针等问题
4. 指针运算：在 C 语言中，可以对指针进行算术运算，例如指针的加法和减法。而在 Go 语言中，指针运算是受限的，不允许进行指针的算术运算(Go保证安全性)
5. 安全性：Go 语言在设计上注重安全性和简洁性，对指针的使用进行了限制，避免了一些常见的错误和安全隐患，如空指针引用和悬挂指针等。这使得 Go 语言相对于 C 语言更容易编写安全和可靠的代码

总体而言，Go 语言对指针的处理更加简化和安全，提供了更高级别的内存管理和类型安全性，而 C 语言则更加底层和灵活，允许更多的指针操作和内存控制。

---

### 函数

函数本质是一个指针 指向其函数的内存地址

#### 匿名函数:

```go
//匿名函数
	var getSum = func(n1, n2 int) (sum, difference int) {
		sum = n1 + n2
		difference = n1 - n2
		return
	}
	// 立即调用的匿名函数
	res3, res4 := func(n1, n2 int) (sum, difference int) {
		sum = n1 + n2
		difference = n1 - n2
		return
	}(2, 3)
```

#### defer: 延迟执行函数

1. 延迟执行的函数会被压入一个栈中 return之后按照先进后出的顺序调用
2. 延迟执行的函数其参数会立即求值
3. defer常用于资源释放、文件关闭、解锁以及记录时间等操作

#### recover 错误捕捉 函数能防止异常错误退出:

```go
func DeferRecover() {
	defer func() {
		err := recover()
		if err != nil {
			fmt.Println("err=", err)
		}
	}()
	n := 0
	fmt.Println(3 / n)
}
```
#### 函数闭包

##### 什么是闭包

>Go 语言支持函数闭包（Function Closure）。闭包是指一个函数值（函数变量）捕获并绑定了其周围的函数体内的变量。这意味着闭包函数可以访问并操作其外部函数中声明的变量，即使外部函数已经返回，闭包仍然可以使用这些变量。
>
>简言之:
>
>当我们谈论闭包时，可以将其想象成一个包裹（closure），里面装着一个函数和一些与函数相关的数据。这个函数可以访问并操作这些数据，即使这些数据在函数外部也是可见的。
>
>闭包通常用于在函数内部创建函数，并且这些函数可以访问函数外部的变量。这就像是在函数内部构建了一个小的「记忆」，可以保存一些数据状态。每当我们调用闭包时，它会记住之前的状态，并在后续调用中保持这些状态的连续性。

闭包在 Go 语言中具有以下特点：

1. 函数变量：在 Go 语言中，函数可以作为一种类型，可以被赋值给变量，作为参数传递给其他函数或者作为返回值。通过将函数赋值给变量，我们可以创建闭包。

2. 引用外部变量：闭包函数可以访问和使用其外部函数中声明的变量，包括函数参数和局部变量。闭包通过引用捕获这些变量，因此即使外部函数执行完毕，闭包仍然可以使用这些变量。

3. 保持状态：闭包函数可以在不同的时间点被调用，而它所捕获的变量将保持其最新的状态。这使得闭包可以用于实现保持状态或者记忆的功能，例如计数器或者延迟执行。

   ```go
   func counter() func() int {
       count := 0
       return func() int {
           count++
           return count
       }
   }
   
   func main() {
       c := counter()
       fmt.Println(c()) // 输出: 1
       fmt.Println(c()) // 输出: 2
       fmt.Println(c()) // 输出: 3
   }
   ```

   在这个例子中，我们定义了一个 `counter` 函数，它返回一个匿名函数。这个匿名函数引用了外部函数中的 `count` 变量。每次调用 `counter` 函数时，都会创建一个新的闭包实例，并且每个实例都保留了自己的 `count` 变量。每次调用闭包函数时，它会增加 `count` 的值并返回。

   闭包的妙处在于它可以记住之前的状态。在这个例子中，无论我们调用多少次闭包函数，它都会记住每次调用的计数值，并保持连续增加。这是因为**闭包函数持有对外部变量的引用**，而不是简单地创建新的变量副本。





## 数组



## Map



## 结构体

## 切片

###  Q1: 切片是什么
在go的源文件中,切片底层是一个结构体

```go
type slice struct {
	array unsafe.Pointer // 指向底层数组
	len   int  // 底层数组的长度
	cap   int  // 底层数组的长度
}
```

当 brr:=arr时,会拷贝slice1给slice2,但是他们Pointer 指针指向的是同一个底层数组 因此操作切片2的同时切片1的内容也会发生变化

![image-20230620105124794](https://cscgblog-1301638685.cos.ap-chengdu.myqcloud.com/java/image-20230620105124794.png)